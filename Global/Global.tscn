[gd_scene load_steps=15 format=2]

[ext_resource path="res://Global/Global.gd" type="Script" id=1]
[ext_resource path="res://default_env.tres" type="Environment" id=2]

[sub_resource type="Animation" id=1]
resource_name = "LoadEnd"
tracks/0/type = "value"
tracks/0/path = NodePath("CanvasLayer/Sprite:material:shader_param/amount")
tracks/0/interp = 1
tracks/0/loop_wrap = true
tracks/0/imported = false
tracks/0/enabled = true
tracks/0/keys = {
"times": PoolRealArray( 0, 1 ),
"transitions": PoolRealArray( 1, 1 ),
"update": 0,
"values": [ 0.0, 1.0 ]
}
tracks/1/type = "value"
tracks/1/path = NodePath("CanvasLayer/LoadPolygon:position")
tracks/1/interp = 1
tracks/1/loop_wrap = true
tracks/1/imported = false
tracks/1/enabled = true
tracks/1/keys = {
"times": PoolRealArray( 0, 1 ),
"transitions": PoolRealArray( 1, 1 ),
"update": 0,
"values": [ Vector2( 0, 0 ), Vector2( 0, -800 ) ]
}
tracks/2/type = "value"
tracks/2/path = NodePath("CanvasLayer/Label:modulate")
tracks/2/interp = 1
tracks/2/loop_wrap = true
tracks/2/imported = false
tracks/2/enabled = true
tracks/2/keys = {
"times": PoolRealArray( 0, 1 ),
"transitions": PoolRealArray( 1, 1 ),
"update": 0,
"values": [ Color( 1, 1, 1, 1 ), Color( 1, 1, 1, 0 ) ]
}

[sub_resource type="Animation" id=2]
resource_name = "LoadStart"
tracks/0/type = "value"
tracks/0/path = NodePath("CanvasLayer/Sprite:material:shader_param/amount")
tracks/0/interp = 1
tracks/0/loop_wrap = true
tracks/0/imported = false
tracks/0/enabled = true
tracks/0/keys = {
"times": PoolRealArray( 0, 1 ),
"transitions": PoolRealArray( 1, 1 ),
"update": 0,
"values": [ 1.0, 0.0 ]
}
tracks/1/type = "value"
tracks/1/path = NodePath("CanvasLayer/LoadPolygon:position")
tracks/1/interp = 1
tracks/1/loop_wrap = true
tracks/1/imported = false
tracks/1/enabled = true
tracks/1/keys = {
"times": PoolRealArray( 0, 1 ),
"transitions": PoolRealArray( 1, 1 ),
"update": 0,
"values": [ Vector2( 0, 800 ), Vector2( 0, 0 ) ]
}
tracks/2/type = "value"
tracks/2/path = NodePath("CanvasLayer/Label:modulate")
tracks/2/interp = 1
tracks/2/loop_wrap = true
tracks/2/imported = false
tracks/2/enabled = true
tracks/2/keys = {
"times": PoolRealArray( 0, 1 ),
"transitions": PoolRealArray( 1, 1 ),
"update": 0,
"values": [ Color( 1, 1, 1, 0 ), Color( 1, 1, 1, 1 ) ]
}

[sub_resource type="Shader" id=3]
code = "shader_type canvas_item;

uniform float amount = 0;

void fragment() {
    COLOR = textureLod(SCREEN_TEXTURE, SCREEN_UV, 0.0) * vec4(amount, amount, amount, 1.0);
}"
custom_defines = ""

[sub_resource type="ShaderMaterial" id=4]
shader = SubResource( 3 )
shader_param/amount = 0.0

[sub_resource type="NoiseTexture" id=5]
width = 1000
height = 1000

[sub_resource type="Animation" id=6]
tracks/0/type = "value"
tracks/0/path = NodePath(".:position")
tracks/0/interp = 1
tracks/0/loop_wrap = true
tracks/0/imported = false
tracks/0/enabled = true
tracks/0/keys = {
"times": PoolRealArray( 0, 1 ),
"transitions": PoolRealArray( 1, 1 ),
"update": 0,
"values": [ Vector2( 0, 0 ), Vector2( 0, -800 ) ]
}

[sub_resource type="Animation" id=7]
tracks/0/type = "value"
tracks/0/path = NodePath(".:position")
tracks/0/interp = 1
tracks/0/loop_wrap = true
tracks/0/imported = false
tracks/0/enabled = true
tracks/0/keys = {
"times": PoolRealArray( 0, 1 ),
"transitions": PoolRealArray( 1, 1 ),
"update": 0,
"values": [ Vector2( 0, 800 ), Vector2( 0, 0 ) ]
}

[sub_resource type="Shader" id=11]
code = "/*
Film Grain post-process shader v1.1	
Martins Upitis (martinsh) devlog-martinsh.blogspot.com
2013

imported to Godot by spl!te 2017

--------------------------
This work is licensed under a Creative Commons Attribution 3.0 Unported License.
So you are free to share, modify and adapt it for your needs, and even use it for commercial use.
I would also love to hear about a project you are using it.

Have fun,
Martins
--------------------------

Perlin noise shader by toneburst:
http://machinesdontcare.wordpress.com/2009/06/25/3d-perlin-noise-sphere-vertex-shader-sourcecode/
*/

shader_type canvas_item;

uniform vec2 screen_size;
uniform bool enabled = false;

uniform float grain_amount = 0.05; //grain amount
uniform bool colored = false; //colored noise?
uniform float color_amount = 0.6;
uniform float grain_size = 1.6; //grain particle size (1.5 - 2.5)
uniform float lum_amount = 1.0;

//a random texture generator, but you can also use a pre-computed perturbation texture
vec4 rnm(vec2 tc, float TIME2) 
{
  float noise =  sin(dot(tc + vec2(TIME2,TIME2),vec2(12.9898,78.233))) * 43758.5453;
	float noiseR =  fract(noise)*2.0-1.0;
    float noiseG =  fract(noise*1.2154)*2.0-1.0; 
    float noiseB =  fract(noise*1.3453)*2.0-1.0;
    float noiseA =  fract(noise*1.3647)*2.0-1.0;
    return vec4(noiseR,noiseG,noiseB,noiseA);
}

float fade(float t) {
    return t*t*t*(t*(t*6.0-15.0)+10.0);
}

float pnoise3D(vec3 p)
{
    vec3 pi = 0.00390625*floor(p);
    pi = vec3(pi.x+0.001953125, pi.y+0.001953125, pi.z+0.001953125);
    vec3 pf = fract(p);     // Fractional part for interpolation

    // Noise contributions from (x=0, y=0), z=0 and z=1
    float perm00 = rnm(pi.xy).a ;
    vec3 grad000 = rnm(vec2(perm00, pi.z)).rgb * 4.0;
    grad000 = vec3(grad000.x - 1.0, grad000.y - 1.0, grad000.z - 1.0);
    float n000 = dot(grad000, pf);
    vec3 grad001 = rnm(vec2(perm00, pi.z + 0.00390625)).rgb * 4.0;
    grad001 = vec3(grad001.x - 1.0, grad001.y - 1.0, grad001.z - 1.0);
    float n001 = dot(grad001, pf - vec3(0.0, 0.0, 1.0));

    // Noise contributions from (x=0, y=1), z=0 and z=1
    float perm01 = rnm(pi.xy + vec2(0.0, 0.00390625)).a ;
    vec3 grad010 = rnm(vec2(perm01, pi.z)).rgb * 4.0;
    grad010 = vec3(grad010.x - 1.0, grad010.y - 1.0, grad010.z - 1.0);
    float n010 = dot(grad010, pf - vec3(0.0, 1.0, 0.0));
    vec3 grad011 = rnm(vec2(perm01, pi.z + 0.00390625)).rgb * 4.0;
    grad011 = vec3(grad011.x - 1.0, grad011.y - 1.0, grad011.z - 1.0);
    float n011 = dot(grad011, pf - vec3(0.0, 1.0, 1.0));

    // Noise contributions from (x=1, y=0), z=0 and z=1
    float perm10 = rnm(pi.xy + vec2(0.00390625, 0.0)).a ;
    vec3  grad100 = rnm(vec2(perm10, pi.z)).rgb * 4.0;
    grad100 = vec3(grad100.x - 1.0, grad100.y - 1.0, grad100.z - 1.0);
    float n100 = dot(grad100, pf - vec3(1.0, 0.0, 0.0));
    vec3  grad101 = rnm(vec2(perm10, pi.z + 0.00390625)).rgb * 4.0;
    grad101 = vec3(grad101.x - 1.0, grad101.y - 1.0, grad101.z - 1.0);
    float n101 = dot(grad101, pf - vec3(1.0, 0.0, 1.0));

    // Noise contributions from (x=1, y=1), z=0 and z=1
    float perm11 = rnm(pi.xy + vec2(0.00390625, 0.00390625)).a ;
    vec3  grad110 = rnm(vec2(perm11, pi.z)).rgb * 4.0;
    grad110 = vec3(grad110.x - 1.0, grad110.y - 1.0, grad110.z - 1.0);
    float n110 = dot(grad110, pf - vec3(1.0, 1.0, 0.0));
    vec3  grad111 = rnm(vec2(perm11, pi.z + 0.00390625)).rgb * 4.0;
    grad111 = vec3(grad111.x - 1.0, grad111.y - 1.0, grad111.z - 1.0);
    float n111 = dot(grad111, pf - vec3(1.0, 1.0, 1.0));

    // Blend contributions along x
    vec4 n_x = mix(vec4(n000, n001, n010, n011), vec4(n100, n101, n110, n111), fade(pf.x));

    // Blend contributions along y
    vec2 n_xy = mix(n_x.xy, n_x.zw, fade(pf.y));

    // Blend contributions along z
    float n_xyz = mix(n_xy.x, n_xy.y, fade(pf.z));

    // We're done, return the final noise value.
    return n_xyz;
}

//2d coordinate orientation thing
vec2 coordRot(vec2 tc, float angle)
{
    float aspect = screen_size.x/screen_size.y;
    float rotX = ((tc.x*2.0-1.0)*aspect*cos(angle)) - ((tc.y*2.0-1.0)*sin(angle));
    float rotY = ((tc.y*2.0-1.0)*cos(angle)) + ((tc.x*2.0-1.0)*aspect*sin(angle));
    rotX = ((rotX/aspect)*0.5+0.5);
    rotY = rotY*0.5+0.5;
    return vec2(rotX,rotY);
}

if (enabled)
{
    vec3 rotOffset = vec3(1.425,3.892,5.835); //rotation offset values	
    vec2 rotCoordsR = coordRot(UV, TIME + rotOffset.x);
    vec3 noise = vec3(pnoise3D(vec3(rotCoordsR*vec2(screen_size.x/grain_size,screen_size.y/grain_size),0.0)));
  
    if (colored)
    {
	    vec2 rotCoordsG = coordRot(UV, TIME + rotOffset.y);
	    vec2 rotCoordsB = coordRot(UV, TIME + rotOffset.z);
	    noise.g = mix(noise.r,pnoise3D(vec3(rotCoordsG*vec2(screen_size.x/grain_size,screen_size.y/grain_size),1.0)),color_amount);
	    noise.b = mix(noise.r,pnoise3D(vec3(rotCoordsB*vec2(screen_size.x/grain_size,screen_size.y/grain_size),2.0)),color_amount);
    }

    vec3 col = tex(TEXTURE, UV).rgb;
    vec3 lumcoeff = vec3(0.299,0.587,0.114);
    float luminance = mix(0.0,dot(col, lumcoeff),lum_amount);
    float lum = smoothstep(0.2,0.0,luminance);
    lum += luminance;

    noise = mix(noise,vec3(0.0),pow(lum,4.0));
    col = col+noise*grain_amount;

    COLOR = vec4(col,1.0) * SRC_COLOR;
} else {
    COLOR = tex(TEXTURE, UV) * SRC_COLOR;
}
"
custom_defines = ""

[sub_resource type="ShaderMaterial" id=12]
shader = SubResource( 11 )

[sub_resource type="OpenSimplexNoise" id=10]

[sub_resource type="NoiseTexture" id=9]
noise = SubResource( 10 )

[sub_resource type="Animation" id=8]
resource_name = "Saved"
length = 4.5
tracks/0/type = "value"
tracks/0/path = NodePath("CanvasLayer/SaveLabel:self_modulate")
tracks/0/interp = 1
tracks/0/loop_wrap = true
tracks/0/imported = false
tracks/0/enabled = true
tracks/0/keys = {
"times": PoolRealArray( 0, 1, 3, 4.5 ),
"transitions": PoolRealArray( 1, 1, 1, 1 ),
"update": 0,
"values": [ Color( 1, 1, 1, 0 ), Color( 1, 1, 1, 1 ), Color( 1, 1, 1, 1 ), Color( 1, 1, 1, 0 ) ]
}

[node name="Node2D" type="Node2D"]
script = ExtResource( 1 )

[node name="LoadPlayer" type="AnimationPlayer" parent="."]
autoplay = "LoadEnd"
playback_speed = 4.0
anims/LoadEnd = SubResource( 1 )
anims/LoadStart = SubResource( 2 )

[node name="CanvasLayer" type="CanvasLayer" parent="."]

[node name="Sprite" type="Sprite" parent="CanvasLayer"]
visible = false
material = SubResource( 4 )
position = Vector2( 508.475, 306.432 )
scale = Vector2( 1.08755, 0.656527 )
z_index = 500
z_as_relative = false
texture = SubResource( 5 )

[node name="LoadPolygon" type="Polygon2D" parent="CanvasLayer"]
color = Color( 0, 0, 0, 1 )
polygon = PoolVector2Array( 0, 0, 0, 800, 512, 650, 1028, 800, 1028, 0, 512, -200 )

[node name="AnimationPlayer" type="AnimationPlayer" parent="CanvasLayer/LoadPolygon"]
anims/Finished = SubResource( 6 )
anims/Loading = SubResource( 7 )

[node name="Label" type="Label" parent="CanvasLayer"]
anchor_left = 1.0
anchor_top = 1.0
anchor_right = 1.0
anchor_bottom = 1.0
margin_left = -94.0
margin_top = -28.0
text = "Loading..."
__meta__ = {
"_edit_use_anchors_": false
}

[node name="SaveLabel" type="Label" parent="CanvasLayer"]
self_modulate = Color( 1, 1, 1, 0 )
anchor_left = 0.023
anchor_top = 1.0
anchor_right = 0.136
anchor_bottom = 1.0
margin_top = -28.0
margin_right = 94.0
text = "Game Progress Saved"
__meta__ = {
"_edit_use_anchors_": false
}

[node name="Sprite2" type="Sprite" parent="CanvasLayer"]
material = SubResource( 12 )
texture = SubResource( 9 )

[node name="WorldEnvironment" type="WorldEnvironment" parent="."]
environment = ExtResource( 2 )

[node name="SavePlayer" type="AnimationPlayer" parent="."]
anims/Saved = SubResource( 8 )
